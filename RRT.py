import numpy as np
from collections import deque
import sys
sys.path.insert(1, '/home/fbartelt/Documents/UFMG/MultiRobot/Jupyterbot')
import jupyterbot as jb

def toroidal_dist(q1, q2):
    N = len(q1)
    weights = np.logspace(0, -5e-2, N)
    #dist = np.linalg.norm(q2 - q1)
    ds = np.array((q1 - q2)**2)
    dist = np.sqrt(weights @ ds.T)

    return dist

class Node:
    def __init__(self, q, parent=None):
        self.children = []
        self.q = q
        self.parent = parent

    def add_children(self, child):
        self.children.append(child)

class RRT:
    """RRT tree based on a premade grid

    Attributes:
    -----------
    root: Node
        The root node.
    grid: np.array
        Grid of the map as a binary matrix (1=Obstacle, 0=Free space).
    path: list
        Generated path to goal as a stack, i.e. reversed follow order.
    max_iter: int
        Max number of iterations for valid random configuration
        generation.
    
    Methods:
    --------
    gen_qrand(qgoal)
        Generates random configuration in free space with uniform 
        distribution.
    find_nearest_q(qrand)
        Finds the nearest configuration in the tree to the random 
        configuration qrand.
    find_next_q(nearest_q, qrand)
        Adds a new node that is 2 meters away from nearest_q in the
        direction of qrand.
    check_collision(nearest_px, next_px)
        Checks if path from nearest_px to next_px is collision-free.
    merge(qnew, tree)
        Merges both trees if there's a path connecting them.
    """

    def __init__(self, robot, q0, q_goal, angles_idx, joint_limits=-1, obstacles=[None], max_iter=1000):
        self.root = Node(q0)
        self.path = None
        self.max_iter = max_iter
        self.angles_idx = angles_idx
        self.dimq = len(q0)
        self.q_goal = q_goal
        self.robot = robot
        self.obstacles = obstacles
        if joint_limits == -1:
            self.joint_limits = self._set_joint_limits()
        else:
            self.joint_limits = joint_limits

    def _set_joint_limits(self):
        joint_lims = [(-10, 10)]*len(self.dimq)
        for i in self.angles_idx:
            joint_lims[i] = (-np.pi, np.pi)
    
    def gen_qrand(self, qgoal=-1, P = 0.6):
        """Generates random configuration in free space with uniform 
        distribution.

        Parameters:
        ----------
        qgoal: Node
            Goal node of current tree (qf if Tinit and q0 if Tgoal)

        Returns:
        --------
        qrand: np.array
            Position of the random configuration in free space. If
            after max_iter iterations qrand is not in free space, None
            is returned.
        """
        collision, counter = 1, 0
        rng = np.random.default_rng()
        qrand = None
        qrand = np.zeros(shape=(self.dimq, 1))
        #qrand = np.zeros(shape=(1, self.dimq))
        p = rng.uniform()
        if qgoal == -1:
            qgoal = self.q_goal.copy()

        distdict = None

        while collision and counter <= self.max_iter:
            if p <= P:
                for i, _ in enumerate(qrand):
                    lim_inf, lim_sup = self.joint_limits[i]
                    row = rng.uniform(lim_inf, lim_sup)
                    qrand[i] = row
                
                qrand = qrand.ravel()
            else:
                qrand = qgoal
            collision, distdict = self.check_collision(qrand, old_dist_struct=distdict, rand_mode=False)
            #free = 1
            counter += 1

        return qrand

    def find_nearest_q(self, qrand):
        """Finds the nearest configuration in the tree to the random 
        configuration.

        Parameters:
        ----------
        qrand: np.array
            Position of the random configuration in free space.
            Generated by gen_qrand()

        Returns:
        --------
        nearest_q: Node
            The node in current tree that is the nearest to qrand
        """
        stack = self.root.children.copy()
        nearest_q = self.root
        qrand_pos = qrand.copy()
        #min_dist = np.linalg.norm(qrand_pos - np.array(nearest_q.q))
        min_dist = toroidal_dist(qrand_pos, nearest_q.q)

        while stack:
            node = stack.pop()
            #curr_dist = np.linalg.norm(qrand_pos - node.q)
            curr_dist = toroidal_dist(qrand_pos, node.q)
            stack.extend(node.children.copy())
            
            if curr_dist <= min_dist:
                nearest_q = node
                min_dist = curr_dist
        
        return nearest_q
    
    def find_next_q(self, nearest_q, qrand, step=1):
        """Adds a new node that is 2 meters away from nearest_q in the
        direction of qrand.

        Parameters:
        ----------
        nearest_q: Node
            The node in current tree that is the nearest to qrand.
            Returned by find_nearest_q
        qrand: np.array
            Position of the random configuration in free space.
            Generated by gen_qrand()

        Returns:
        --------
        next_q: Node
            A new node 2 meters away from nearest_q in direction of
            qrand.
        """
        #xrand, yrand = qrand
        near_pos = np.array(nearest_q.q)
        next_vec = qrand - near_pos
        norm_vec = next_vec / (toroidal_dist(qrand, near_pos) + 1e-6)
        next_q = near_pos + step * norm_vec
        
        collision, old_dist_struct = self.check_path_collision(nearest_q.q, next_q)
        #collision, old_dist_struct = self.check_collision(q=next_q)
        
        if not collision:
            next_q = Node(next_q, parent=nearest_q)
        else:
            next_q = None
        
        return next_q

    def check_selfcollision(self, q, tol=2e-3):
        dists = []
        htm_list = self.robot.fkm(q=q, axis='dh')
        collision = False
        
        for i, links_i in enumerate(self.robot.links):
            for j in range(i+1, len(self.robot.links)):
                
                for (obj_i, mth_i) in links_i.col_objects:
                    obj_i.set_ani_frame(htm=htm_list[i] @ mth_i)
                    
                    for (obj_j, mth_j) in self.robot.links[j].col_objects:
                        obj_j.set_ani_frame(htm=htm_list[j] @ mth_j)
                        _, _, d = jb.Utils.compute_hg_dist(obj_i, obj_j, h=1e-4, g=1e-4)
        
                        if d < tol:
                            collision = True
                            return collision
                        dists.append(d)
        
        collision = min(dists) < tol
        if collision:
            print('SELF COLIDE')
        return collision
    
    def check_collision(self, q, old_dist_struct=None, rand_mode=False):
        collision = False
        distdict = None

        if not rand_mode:
            collision = self.check_selfcollision(q)
        if not collision or rand_mode:
            for obstacle in self.obstacles:
                distdict = self.robot.compute_hg_dist(obstacle, q=q, old_dist_struct=old_dist_struct)
                collision = collision or (distdict.get_closest_item()["hgDistance"] <= 1e-2)

        return collision, distdict

    def check_path_collision(self, q_init, q_final, collision=False, old_dist_struct=None, old_diff=0):
        col, old_dist_struct = self.check_collision(q_init, old_dist_struct=old_dist_struct)
        collision = collision or col
        col, old_dist_struct = self.check_collision(q_final, old_dist_struct=old_dist_struct)
        collision = collision or col

        if not collision:
            q_mid = q_init + (q_final - q_init) / 2
            diff_inf = toroidal_dist(q_init, q_mid)
            diff_sup = toroidal_dist(q_mid, q_final)
            #if np.linalg.norm(np.array(q_mid) - q_init) <= 100:
            if (np.linalg.norm(diff_inf - old_diff) <= 1e-1) or (np.linalg.norm(diff_sup - old_diff) <= 1e-1):
                return collision, old_dist_struct

            col, old_dist_struct = self.check_collision(q_mid, old_dist_struct=old_dist_struct)
            collision = collision or col
            
            if not collision:
                collision_left, old_dist_struct = self.check_path_collision(q_init, q_mid, collision=collision,
                                                        old_dist_struct=old_dist_struct, old_diff=diff_inf)
                collision = collision or collision_left
                if not collision:
                    collision_right, old_dist_struct = self.check_path_collision(q_mid, q_final, collision=collision,
                                                            old_dist_struct=old_dist_struct, old_diff=diff_sup)
                    collision = collision or collision_right
        
        return collision, old_dist_struct
    
    def pruning(self, path=-1):
        if path == -1:
            path = self.path.copy()
        old_dist = None
        for i, q in enumerate(path):
            for j in range(i+2, len(path)):
                q2 = path[j]
                if q is not None and q2 is not None:
                    if toroidal_dist(q, q2) <= 0.25:
                        collision, old_dist = self.check_path_collision(q, q2, old_dist_struct=old_dist)
                        if not collision:
                            path[i+1:j] = [None] * (j - (i + 1))
        path = [x for x in path if x is not None]

        return path

    def merge(self, qnew, tree, prune=True):
        """Merges both trees if there's a path connecting them. 
        Merging implies that self.path is updated. tree.path is also
        updated and it is a reversed version of self.path. Both paths
        are stacks, such that the correct order to reach tree.root from
        self.root is self.path[-1], self.path[-2], ..., self.path[0].

        Parameters:
        ----------
        qnew: Node
            Last node generated by find_next_q().
        tree: RRT
            The other RRT (e.g. Tgoal if self == Tinit).

        Returns:
        --------
        collision: int (bool)
            0 if there is no collision in path nearest_q -> next_q
            1 if there is no collision-free path.
        """
        nearest_q = tree.find_nearest_q(qnew.q)
        path = []
        dist = toroidal_dist(qnew.q, nearest_q.q)
        collision = True

        if dist <= 0.25:
            #print('merge',end='')
            #print('dist passed', end='')
            #input(f'({nearest_q.q}, {qnew.q})')
            collision, _ = tree.check_path_collision(nearest_q.q, qnew.q)
            #print('checked',end='')
            if not collision:
                
                for node in [nearest_q, qnew]:
                    curr = node
                    while curr:
                        path.append(curr.q)
                        curr = curr.parent
                    path = path[::-1]
                if prune:
                    path = self.pruning(path)
                self.path = path[::-1]
                tree.path = path
                print('MERGED!')
            
        return collision

def run_RRT(Tinit, Tgoal, max_iter=15000, step=1, P=0.8):
    """Executes RRT planner.

    Parameters:
    ----------
    Tinit: RRT
        Initial position RRT.
    Tgoal: RRT
        Goal RRT.
    max_iter: int
        Max iterations to try generating a path from initial
        configuration to goal configuration.
    """
    trees = deque([Tinit, Tgoal])
    counter, disc = 0, 1

    while disc and counter <= max_iter:
        tree = trees[0]
        qrand = tree.gen_qrand(P=P)
        if qrand is not None:
            qnearest = tree.find_nearest_q(qrand)
            qnext = tree.find_next_q(qnearest, qrand, step=step)

            if qnext:
                qnearest.add_children(qnext)
                disc = tree.merge(qnext, trees[1])
            
        counter += 1
        trees.rotate()
    
    if disc:
        print('MAX ITERATION REACHED: ', counter)
    return counter